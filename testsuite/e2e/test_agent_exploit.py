"""
Tests for the Exploit Agent
Validates Metasploit integration, exploit selection, payload delivery, and safety checks
"""
import pytest
import asyncio
from typing import Dict, Any, List
from unittest.mock import Mock, patch

from src.utils import APIClient, validate_response_schema, DataManager
from src.os_queries import OpenSearchClient, OpenSearchQueries
from src.dummy_generators import generate_test_tenant_id


@pytest.mark.asyncio
@pytest.mark.exploit
@pytest.mark.smoke
async def test_exploit_agent_basic_vulnerability_scan(api_client: APIClient):
    """Test exploit agent can identify vulnerabilities without exploitation"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "exploit_mode": "scan_only",  # No actual exploitation,
        "max_risk_level": "low",
        "inputs": {
            "targets": ["192.168.1.100"],
            "depth": "basic",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    assert "run_id" in response
    assert "plan_id" in response
    
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=180, interval=10)
    
    # Get final status
    final_status = await api_client.get(f"/runs/{run_id}")
    assert final_status["status"] == "completed"
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    
    # Should have exploit results
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    assert len(exploit_results) > 0, "Should have exploit agent results"
    
    # Validate exploit result structure
    exploit_result = exploit_results[0]
    required_fields = ["agent", "target", "findings", "scan_type", "vulnerabilities_found"]
    validate_response_schema(exploit_result, required_fields)
    
    assert exploit_result["agent"] == "exploit"
    assert exploit_result["scan_type"] == "vulnerability_scan"
    assert isinstance(exploit_result["vulnerabilities_found"], int)
    assert exploit_result["vulnerabilities_found"] >= 0


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_metasploit_integration(api_client: APIClient):
    """Test exploit agent integrates with Metasploit RPC"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "exploit_mode": "identify_only",
        "metasploit_enabled": True,
        "inputs": {
            "targets": ["10.0.0.50"],  # Test target with known vulnerabilities,
            "depth": "standard",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=240, interval=15)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    assert len(exploit_results) > 0, "Should have exploit results"
    
    # Validate Metasploit integration
    exploit_result = exploit_results[0]
    
    if "tools_used" in exploit_result:
        assert "metasploit" in exploit_result["tools_used"], "Should use Metasploit"
    
    if "findings" in exploit_result and len(exploit_result["findings"]) > 0:
        finding = exploit_result["findings"][0]
        
        # Should have exploit-specific fields
        exploit_fields = ["vulnerability_type", "severity", "exploit_available"]
        for field in exploit_fields:
            if field in finding:
                if field == "severity":
                    assert finding[field] in ["critical", "high", "medium", "low", "info"]
                elif field == "exploit_available":
                    assert isinstance(finding[field], bool)


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_payload_selection(api_client: APIClient):
    """Test exploit agent selects appropriate payloads"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "exploit_mode": "test_payloads",
        "allowed_payloads": ["meterpreter", "shell", "reverse_tcp"],
        "target_os": "windows",
        "inputs": {
            "targets": ["172.16.1.200"],
            "depth": "advanced",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=300, interval=20)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    if len(exploit_results) > 0:
        exploit_result = exploit_results[0]
        
        # Check payload information
        if "payloads_tested" in exploit_result:
            payloads = exploit_result["payloads_tested"]
            assert isinstance(payloads, list)
            
            # Should only use allowed payloads
            allowed = ["meterpreter", "shell", "reverse_tcp"]
            for payload in payloads:
                assert any(allowed_type in payload for allowed_type in allowed), \
                    f"Payload {payload} not in allowed list"
        
        # Check targeting is appropriate
        if "target_info" in exploit_result:
            target_info = exploit_result["target_info"]
            if "os_family" in target_info:
                assert "windows" in target_info["os_family"].lower(), \
                    "Should target Windows as specified"


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_safety_constraints(api_client: APIClient):
    """Test exploit agent respects safety constraints"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "exploit_mode": "scan_only",  # Most restrictive,
        "max_risk_level": "low",
        "forbidden_exploits": ["privilege_escalation", "persistence", "lateral_movement"],
        "production_target": True,
        "inputs": {
            "targets": ["10.10.10.100"],
            "depth": "comprehensive",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=180, interval=10)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    if len(exploit_results) > 0:
        exploit_result = exploit_results[0]
        
        # Should not perform actual exploitation
        assert exploit_result.get("exploitation_attempted", False) == False, \
            "Should not attempt exploitation in scan_only mode"
        
        # Check findings respect risk level
        if "findings" in exploit_result:
            for finding in exploit_result["findings"]:
                if "severity" in finding:
                    assert finding["severity"] in ["low", "info"], \
                        f"Finding severity {finding['severity']} exceeds max_risk_level"
                
                # Should not contain forbidden exploit types
                if "exploit_type" in finding:
                    forbidden = ["privilege_escalation", "persistence", "lateral_movement"]
                    assert not any(forbidden_type in finding["exploit_type"].lower() 
                                 for forbidden_type in forbidden), \
                        f"Found forbidden exploit type: {finding['exploit_type']}"


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_vulnerability_database(api_client: APIClient):
    """Test exploit agent uses vulnerability databases effectively"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "use_cve_database": True,
        "use_exploit_db": True,
        "min_cvss_score": 7.0,
        "inputs": {
            "targets": ["192.168.100.50"],
            "depth": "standard",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=200, interval=15)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    if len(exploit_results) > 0:
        exploit_result = exploit_results[0]
        
        # Check vulnerability database usage
        if "databases_used" in exploit_result:
            databases = exploit_result["databases_used"]
            assert isinstance(databases, list)
            assert "cve" in [db.lower() for db in databases], "Should use CVE database"
        
        # Check findings have CVE/database references
        if "findings" in exploit_result:
            for finding in exploit_result["findings"]:
                # Should have vulnerability identifiers
                has_cve = "cve_id" in finding
                has_exploit_db = "exploit_db_id" in finding
                has_reference = "references" in finding
                
                assert has_cve or has_exploit_db or has_reference, \
                    "Finding should have vulnerability database reference"
                
                # Check CVSS score filtering
                if "cvss_score" in finding:
                    assert finding["cvss_score"] >= 7.0, \
                        f"CVSS score {finding['cvss_score']} below minimum threshold"


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_service_specific_exploits(api_client: APIClient):
    """Test exploit agent identifies service-specific vulnerabilities"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "target_services": ["http", "ssh", "smb", "ftp"],
        "exploit_mode": "service_scan",
        "inputs": {
            "targets": ["10.0.1.150"],
            "depth": "advanced",
            "features": ["recon", "exploit"],  # Include recon to identify services,
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=300, interval=20)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    if len(exploit_results) > 0:
        exploit_result = exploit_results[0]
        
        # Should have service-specific findings
        if "findings" in exploit_result:
            services_found = set()
            for finding in exploit_result["findings"]:
                if "service" in finding:
                    services_found.add(finding["service"].lower())
                elif "port" in finding:
                    # Map common ports to services
                    port_to_service = {
                        80: "http", 443: "http", 22: "ssh", 
                        445: "smb", 21: "ftp", 23: "telnet"
                    }
                    if finding["port"] in port_to_service:
                        services_found.add(port_to_service[finding["port"]])
            
            # Should find at least some targeted services
            target_services = {"http", "ssh", "smb", "ftp"}
            found_targeted = services_found.intersection(target_services)
            # In simulation, might not find all, but should identify some
        
        # Check service-specific exploit categorization
        if "exploit_categories" in exploit_result:
            categories = exploit_result["exploit_categories"]
            service_categories = ["web_app", "ssh_attack", "smb_exploit", "ftp_attack"]
            # Should have some service-specific categories


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_error_handling(api_client: APIClient):
    """Test exploit agent handles errors gracefully"""
    # Test with invalid target
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "inputs": {
            "targets": ["999.999.999.999"],  # Invalid IP,
            "depth": "basic",
            "features": ["exploit"],
            "simulate": True
        }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=120, interval=10)
    
    # Should handle gracefully
    final_status = await api_client.get(f"/runs/{run_id}")
    assert final_status["status"] in ["completed", "failed"], "Should complete or fail gracefully"
    
    # Check results for error handling
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    if len(exploit_results) > 0:
        exploit_result = exploit_results[0]
        
        # Should have error information
        if final_status["status"] == "failed":
            assert "error" in exploit_result or "errors" in exploit_result, \
                "Failed run should have error information"
        
        # Should not crash
        assert "status" in exploit_result
        assert exploit_result["status"] in ["completed", "failed", "error"]


@pytest.mark.asyncio
@pytest.mark.exploit
async def test_exploit_agent_logging_to_opensearch(opensearch_client: OpenSearchClient, test_config: Dict):
    """Test exploit agent actions are logged to OpenSearch"""
    # Run a simple exploit scan
    from src.utils import APIClient
    api_client = APIClient(test_config["api_base"])
    
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "inputs": {
            "targets": ["127.0.0.1"],
            "depth": "basic",
            "features": ["exploit"],
            "simulate": True
        }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=120, interval=10)
    
    # Allow time for logging
    await asyncio.sleep(5)
    await opensearch_client.refresh_index(test_config["os_idx_actions"])
    
    # Search for exploit agent actions
    query = OpenSearchQueries.bool_query(
        must=[
            OpenSearchQueries.term_query("run_id", run_id),
            OpenSearchQueries.term_query("agent", "exploit")
        ]
    )
    
    docs = await opensearch_client.search(test_config["os_idx_actions"], query)
    assert docs["hits"]["total"]["value"] >= 1, "Should have exploit agent action logged"
    
    # Validate exploit action document
    action_doc = docs["hits"]["hits"][0]["_source"]
    
    required_fields = ["run_id", "agent", "tool", "status", "started_at", "ended_at"]
    validate_response_schema(action_doc, required_fields)
    
    assert action_doc["agent"] == "exploit"
    assert action_doc["tool"] in ["metasploit", "nmap", "exploit_scan", "vulnerability_scan"]
    assert action_doc["status"] in ["completed", "failed", "error"]


@pytest.mark.asyncio  
@pytest.mark.exploit
async def test_exploit_agent_multiple_targets(api_client: APIClient):
    """Test exploit agent handles multiple targets efficiently"""
    run_input = {
        "tenant_id": generate_test_tenant_id(),
        "auto_plan": True,
        "policy": {,
        "parallel_targets": True,
        "max_concurrent": 2,
        "inputs": {
            "targets": ["192.168.1.10", "192.168.1.20", "192.168.1.30"],
            "depth": "standard",
            "features": ["exploit"],
            "simulate": True
        }
    }
    }
    
    response = await api_client.post("/agents/pentest/run", run_input)
    run_id = response["run_id"]
    
    # Wait for completion
    from src.utils import wait_for_condition
    
    async def check_completed():
        status = await api_client.get(f"/runs/{run_id}")
        return status["status"] in ["completed", "failed", "error"]
    
    await wait_for_condition(check_completed, timeout=400, interval=20)
    
    # Get results
    results = await api_client.get(f"/runs/{run_id}/results")
    exploit_results = [r for r in results["results"] if r["agent"] == "exploit"]
    
    # Should have results for multiple targets
    assert len(exploit_results) >= 1, "Should have exploit results"
    
    # Check if multiple targets were processed
    targets_processed = set()
    for result in exploit_results:
        if "target" in result:
            targets_processed.add(result["target"])
    
    # Should process some targets (in simulation, might not be all)
    assert len(targets_processed) >= 1, "Should process at least one target"
