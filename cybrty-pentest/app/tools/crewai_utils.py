"""Utility functions for CrewAI tool integration."""

import asyncio
import json
import os
import subprocess
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from xml.etree import ElementTree as ET

import aiofiles
import structlog

logger = structlog.get_logger(__name__)


class AsyncShellRunner:
    """Async shell command runner with timeout and logging."""
    
    @staticmethod
    async def run_command(
        cmd: List[str],
        cwd: Optional[str] = None,
        timeout: int = 300,
        capture_output: bool = True
    ) -> Tuple[int, str, str]:
        """Run shell command asynchronously."""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                cwd=cwd
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout
            )
            
            return (
                process.returncode if process.returncode is not None else -1,
                stdout.decode('utf-8', errors='ignore') if stdout else '',
                stderr.decode('utf-8', errors='ignore') if stderr else ''
            )
            
        except asyncio.TimeoutError:
            logger.error("Command timeout", cmd=cmd, timeout=timeout)
            if process:
                process.kill()
                await process.wait()
            return -1, '', f'Command timed out after {timeout} seconds'
            
        except Exception as e:
            logger.error("Command execution failed", cmd=cmd, error=str(e))
            return -1, '', str(e)


class ArtifactManager:
    """Manage artifacts and file operations."""
    
    def __init__(self, base_dir: str):
        """Initialize artifact manager."""
        self.base_dir = Path(base_dir)
        self.base_dir.mkdir(parents=True, exist_ok=True)
    
    def create_run_directory(self, run_id: str) -> Path:
        """Create directory for a specific run."""
        run_dir = self.base_dir / run_id
        run_dir.mkdir(parents=True, exist_ok=True)
        return run_dir
    
    def get_artifact_path(self, run_id: str, filename: str) -> Path:
        """Get path for artifact file."""
        run_dir = self.create_run_directory(run_id)
        return run_dir / self.sanitize_filename(filename)
    
    @staticmethod
    def sanitize_filename(filename: str) -> str:
        """Sanitize filename for safe file operations."""
        import re
        # Remove or replace unsafe characters
        filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
        filename = re.sub(r'[^\w\-_\.]', '_', filename)
        return filename[:255]  # Limit length
    
    async def save_artifact(
        self, 
        run_id: str, 
        filename: str, 
        content: str,
        mode: str = 'w'
    ) -> str:
        """Save artifact to file."""
        filepath = self.get_artifact_path(run_id, filename)
        
        try:
            async with aiofiles.open(filepath, mode) as f:
                await f.write(content)
            
            logger.info("Artifact saved", path=str(filepath))
            return str(filepath)
            
        except Exception as e:
            logger.error("Failed to save artifact", path=str(filepath), error=str(e))
            raise


class OutputParser:
    """Parse tool outputs into structured data."""
    
    @staticmethod
    def parse_nmap_xml(xml_content: str) -> Dict[str, Any]:
        """Parse Nmap XML output."""
        try:
            root = ET.fromstring(xml_content)
            hosts = []
            
            for host in root.findall('host'):
                # Get host state
                status = host.find('status')
                if status is None or status.get('state') != 'up':
                    continue
                
                # Get IP address
                address = host.find('address')
                ip = address.get('addr') if address is not None else 'unknown'
                
                # Get hostnames
                hostnames = []
                hostnames_elem = host.find('hostnames')
                if hostnames_elem is not None:
                    for hostname in hostnames_elem.findall('hostname'):
                        hostnames.append(hostname.get('name'))
                
                # Get ports
                ports = []
                ports_elem = host.find('ports')
                if ports_elem is not None:
                    for port in ports_elem.findall('port'):
                        port_id = port.get('portid')
                        protocol = port.get('protocol')
                        
                        state = port.find('state')
                        state_value = state.get('state') if state is not None else 'unknown'
                        
                        service = port.find('service')
                        service_name = service.get('name') if service is not None else 'unknown'
                        service_product = service.get('product') if service is not None else ''
                        service_version = service.get('version') if service is not None else ''
                        
                        ports.append({
                            'port': int(port_id),
                            'protocol': protocol,
                            'state': state_value,
                            'service': service_name,
                            'product': service_product,
                            'version': service_version
                        })
                
                hosts.append({
                    'ip': ip,
                    'hostnames': hostnames,
                    'ports': ports,
                    'state': 'up'
                })
            
            return {
                'hosts': hosts,
                'summary': {
                    'total_hosts': len(hosts),
                    'scan_time': datetime.utcnow().isoformat()
                }
            }
            
        except ET.ParseError as e:
            logger.error("Failed to parse Nmap XML", error=str(e))
            return {'error': f'XML parse error: {e}', 'hosts': []}
        except Exception as e:
            logger.error("Unexpected error parsing Nmap XML", error=str(e))
            return {'error': str(e), 'hosts': []}
    
    @staticmethod
    def parse_amass_output(output: str) -> Dict[str, Any]:
        """Parse Amass output."""
        subdomains = []
        lines = output.strip().split('\n')
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                subdomains.append(line)
        
        return {
            'subdomains': subdomains,
            'total_found': len(subdomains),
            'scan_time': datetime.utcnow().isoformat()
        }
    
    @staticmethod
    def parse_nikto_output(output: str) -> Dict[str, Any]:
        """Parse Nikto output."""
        findings = []
        current_target = None
        
        lines = output.split('\n')
        for line in lines:
            line = line.strip()
            
            if line.startswith('+ Target IP:') or line.startswith('+ Target Host:'):
                current_target = line.split(':', 1)[1].strip()
            elif line.startswith('+') and current_target:
                # This is a finding
                findings.append({
                    'target': current_target,
                    'finding': line[1:].strip(),
                    'severity': 'info'  # Default severity
                })
        
        return {
            'findings': findings,
            'target': current_target,
            'total_findings': len(findings),
            'scan_time': datetime.utcnow().isoformat()
        }
    
    @staticmethod
    def parse_hydra_output(output: str) -> Dict[str, Any]:
        """Parse Hydra output."""
        credentials = []
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            if '[' in line and ']' in line and 'login:' in line:
                # Parse successful login
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == 'login:' and i + 1 < len(parts):
                        login = parts[i + 1]
                    elif part == 'password:' and i + 1 < len(parts):
                        password = parts[i + 1]
                        credentials.append({
                            'username': login,
                            'password': password,
                            'service': 'unknown'
                        })
        
        return {
            'credentials': credentials,
            'total_found': len(credentials),
            'scan_time': datetime.utcnow().isoformat()
        }


def generate_step_id() -> str:
    """Generate unique step ID."""
    return str(uuid.uuid4())


def validate_network_target(target: str, allowed_networks: List[str]) -> bool:
    """Validate if target is within allowed networks."""
    import ipaddress
    
    try:
        # Handle CIDR notation
        if '/' in target:
            target_network = ipaddress.ip_network(target, strict=False)
        else:
            target_network = ipaddress.ip_network(f"{target}/32", strict=False)
        
        for allowed_net in allowed_networks:
            allowed_network = ipaddress.ip_network(allowed_net)
            if target_network.subnet_of(allowed_network) or target_network == allowed_network:
                return True
        
        return False
        
    except ipaddress.AddressValueError:
        # If it's not an IP, assume it's a hostname (allowed)
        return True
