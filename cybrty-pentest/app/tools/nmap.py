"""Nmap tool wrapper for CrewAI."""

import json
from typing import Any, Dict, Optional, List

from crewai.tools import BaseTool
from pydantic import BaseModel, Field

from ..core.config import Settings
from .crewai_utils import AsyncShellRunner, ArtifactManager, OutputParser, validate_network_target


class NmapInput(BaseModel):
    """Input schema for Nmap tool."""
    target: str = Field(..., description="Target IP, hostname, or CIDR range")
    profile: str = Field(default="-sV -T4", description="Nmap scan profile/options")
    output_format: str = Field(default="xml", description="Output format (xml, json)")


class NmapTool(BaseTool):
    """Nmap network scanner tool for CrewAI."""
    
    name: str = "nmap_scanner"
    description: str = """
    Network scanner tool using Nmap. Performs host discovery and service enumeration.
    
    Use this tool to:
    - Discover live hosts in a network range
    - Identify open ports and running services
    - Perform service version detection
    - Generate network reconnaissance reports
    
    Always respects network policy restrictions and rate limits.
    """
    args_schema: type[BaseModel] = NmapInput
    
    def __init__(self, settings: Settings, opensearch_logger=None, **kwargs):
        """Initialize Nmap tool."""
        super().__init__(**kwargs)
        # Store settings in a way that doesn't conflict with Pydantic
        object.__setattr__(self, '_settings', settings)
        object.__setattr__(self, '_shell_runner', AsyncShellRunner())
        
        # DEBUG: Log what we received for opensearch_logger
        from ..core.logger import logger
        logger.debug("NmapTool.__init__", 
                    opensearch_logger_type=type(opensearch_logger).__name__ if opensearch_logger else "None",
                    opensearch_logger_available=bool(opensearch_logger))
        
        object.__setattr__(self, '_artifact_manager', ArtifactManager(settings.artifacts.dir, opensearch_logger))
        object.__setattr__(self, '_parser', OutputParser())
    
    @property
    def settings(self) -> Settings:
        """Get settings."""
        return self._settings
    
    @property
    def shell_runner(self) -> AsyncShellRunner:
        """Get shell runner."""
        return self._shell_runner
    
    @property  
    def artifact_manager(self) -> ArtifactManager:
        """Get artifact manager."""
        return self._artifact_manager
        
    @property
    def parser(self) -> OutputParser:
        """Get output parser."""
        return self._parser
    
    def _run(
        self, 
        target: str, 
        profile: str = "-sV -T4",
        output_format: str = "xml",
        **kwargs
    ) -> str:
        """Run Nmap scan synchronously."""
        import asyncio
        return asyncio.run(self._arun(target, profile, output_format, **kwargs))
    
    async def _arun(
        self,
        target: str,
        profile: str = "-sV -T4", 
        output_format: str = "xml",
        **kwargs
    ) -> str:
        """Run Nmap scan asynchronously."""
        try:
            # Validate target against policy
            if not validate_network_target(target, self.settings.policy.allow_networks):
                return json.dumps({
                    "error": f"Target {target} is not within allowed networks",
                    "allowed_networks": self.settings.policy.allow_networks
                })
            
            # Check host count limits for CIDR ranges
            if '/' in target:
                import ipaddress
                try:
                    network = ipaddress.ip_network(target, strict=False)
                    if network.num_addresses > self.settings.policy.max_host_count:
                        return json.dumps({
                            "error": f"Target network {target} exceeds max host count limit",
                            "max_hosts": self.settings.policy.max_host_count
                        })
                except Exception:
                    pass  # Not a valid network, continue as hostname
            
            # Build Nmap command
            nmap_binary = self.settings.tools.binaries.nmap
            cmd = [nmap_binary]
            
            # Add profile options
            if profile:
                cmd.extend(profile.split())
            
            # Force XML output for parsing
            cmd.extend(["-oX", "-"])
            cmd.append(target)
            
            # Execute scan
            returncode, stdout, stderr = await self.shell_runner.run_command(
                cmd, timeout=600  # 10 minute timeout for network scans
            )
            
            if returncode != 0:
                return json.dumps({
                    "error": f"Nmap scan failed: {stderr}",
                    "returncode": returncode
                })
            
            # Parse results
            if output_format == "xml":
                # Return raw XML if requested
                result = {
                    "raw_output": stdout,
                    "format": "xml",
                    "target": target,
                    "profile": profile,
                    "artifacts": {}
                }
            else:
                # Parse XML to JSON
                parsed_result = self.parser.parse_nmap_xml(stdout)
                result = {
                    "parsed_output": parsed_result,
                    "format": "json", 
                    "target": target,
                    "profile": profile,
                    "artifacts": {}
                }
            
            # Save artifacts
            run_id = kwargs.get('run_id', 'standalone')
            if run_id:
                xml_path = await self.artifact_manager.save_artifact(
                    run_id, f"nmap_{target.replace('/', '_')}.xml", stdout
                )
                
                json_path = await self.artifact_manager.save_artifact(
                    run_id, f"nmap_{target.replace('/', '_')}.json", 
                    json.dumps(result, indent=2)
                )
                
                result["artifacts"] = {
                    "xml_report": xml_path,
                    "json_report": json_path
                }
            
            return json.dumps(result, indent=2)
            
        except Exception as e:
            return json.dumps({
                "error": f"Nmap tool execution failed: {str(e)}",
                "target": target
            })
    
    def get_summary(self, result: str) -> str:
        """Get human-readable summary of scan results."""
        try:
            data = json.loads(result)
            
            if "error" in data:
                return f"Nmap scan failed: {data['error']}"
            
            if "parsed_output" in data:
                parsed = data["parsed_output"]
                hosts = parsed.get("hosts", [])
                
                if not hosts:
                    return f"No live hosts found on target {data['target']}"
                
                summary = f"Found {len(hosts)} live host(s) on {data['target']}:\n"
                
                for host in hosts[:5]:  # Show first 5 hosts
                    ip = host.get("ip", "unknown")
                    ports = host.get("ports", [])
                    open_ports = [p for p in ports if p.get("state") == "open"]
                    
                    summary += f"  - {ip}: {len(open_ports)} open port(s)"
                    if open_ports:
                        top_ports = [f"{p['port']}/{p['protocol']}" for p in open_ports[:3]]
                        summary += f" ({', '.join(top_ports)}{'...' if len(open_ports) > 3 else ''})"
                    summary += "\n"
                
                if len(hosts) > 5:
                    summary += f"  ... and {len(hosts) - 5} more hosts"
                
                return summary
            
            return f"Nmap scan completed on {data.get('target', 'unknown target')}"
            
        except Exception:
            return "Nmap scan completed (unable to parse results)"


class NmapAgent:
    """Legacy Nmap network scanning agent for backwards compatibility."""

    def __init__(self, settings, opensearch_logger=None):
        """Initialize Nmap agent."""
        if hasattr(settings, 'tools') and hasattr(settings.tools, 'binaries'):
            self.binary_path = settings.tools.binaries.nmap
        else:
            # Fallback for backwards compatibility
            self.binary_path = settings if isinstance(settings, str) else "nmap"
        self.settings = settings
        self.opensearch_logger = opensearch_logger

    async def scan(
        self,
        target: str,
        profile: str = "-sV -T4",
        artifacts_dir: str = "/tmp",
        run_id: str = "test",
        step_id: str = "nmap1",
        allowed_networks: Optional[List[str]] = None,
        max_host_count: int = 4096,
        simulate: bool = True
    ) -> Dict[str, Any]:
        """Perform Nmap scan on target - legacy method."""
        from datetime import datetime
        
        started_at = datetime.utcnow()
        
        try:
            # For legacy compatibility, create a NmapTool instance
            from ..core.config import get_settings
            settings = get_settings()
            tool = NmapTool(settings)
            
            # Run the scan using the new tool
            result_str = await tool._arun(target, profile, "json", run_id=run_id)
            result_data = json.loads(result_str)
            
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            
            # Convert to legacy format
            if "error" in result_data:
                return {
                    "status": "error",
                    "agent": "recon",
                    "tool": "nmap",
                    "params": {"target": target, "profile": profile},
                    "summary": {"error": result_data["error"]},
                    "artifacts": {},
                    "started_at": started_at.isoformat(),
                    "ended_at": ended_at.isoformat(),
                    "duration_ms": duration_ms
                }
            else:
                parsed_output = result_data.get("parsed_output", {})
                return {
                    "status": "success",
                    "agent": "recon",
                    "tool": "nmap",
                    "params": {"target": target, "profile": profile},
                    "summary": parsed_output,
                    "artifacts": result_data.get("artifacts", {}),
                    "started_at": started_at.isoformat(),
                    "ended_at": ended_at.isoformat(),
                    "duration_ms": duration_ms
                }

        except Exception as e:
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            
            return {
                "status": "error",
                "agent": "recon",
                "tool": "nmap", 
                "params": {"target": target, "profile": profile},
                "summary": {"error": str(e)},
                "artifacts": {},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }
