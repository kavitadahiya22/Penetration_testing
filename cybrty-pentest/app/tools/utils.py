"""Utility functions for pentesting tools."""

import asyncio
import os
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import structlog

logger = structlog.get_logger(__name__)


async def run_command(
    command: List[str],
    timeout: int = 300,
    cwd: Optional[str] = None,
    env: Optional[Dict[str, str]] = None
) -> Tuple[int, str, str]:
    """Run a shell command asynchronously with timeout."""
    try:
        # Merge environment variables
        proc_env = os.environ.copy()
        if env:
            proc_env.update(env)

        process = await asyncio.create_subprocess_exec(
            *command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=cwd,
            env=proc_env
        )
        
        stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
        
        return process.returncode, stdout.decode('utf-8', errors='replace'), stderr.decode('utf-8', errors='replace')
        
    except asyncio.TimeoutError:
        if process:
            process.terminate()
            await process.wait()
        raise asyncio.TimeoutError(f"Command timed out after {timeout} seconds")
    except Exception as e:
        logger.error("Failed to run command", command=command, error=str(e))
        raise


async def run_command_with_artifacts(
    command: List[str],
    artifacts_dir: str,
    run_id: str,
    step_id: str,
    timeout: int = 300,
    cwd: Optional[str] = None,
    env: Optional[Dict[str, str]] = None
) -> Tuple[int, str, str, Dict[str, str]]:
    """Run command and save output artifacts."""
    # Create artifact directory
    artifact_path = Path(artifacts_dir) / run_id / step_id
    artifact_path.mkdir(parents=True, exist_ok=True)
    
    # Run command
    returncode, stdout, stderr = await run_command(command, timeout, cwd, env)
    
    # Save artifacts
    artifacts = {}
    
    # Save stdout
    stdout_file = artifact_path / "stdout.log"
    with open(stdout_file, 'w') as f:
        f.write(stdout)
    artifacts["stdout"] = f"file://{stdout_file}"
    
    # Save stderr
    stderr_file = artifact_path / "stderr.log"
    with open(stderr_file, 'w') as f:
        f.write(stderr)
    artifacts["stderr"] = f"file://{stderr_file}"
    
    # Save command info
    command_file = artifact_path / "command.txt"
    with open(command_file, 'w') as f:
        f.write(f"Command: {' '.join(command)}\n")
        f.write(f"Return code: {returncode}\n")
        f.write(f"Timestamp: {datetime.utcnow().isoformat()}\n")
    artifacts["command"] = f"file://{command_file}"
    
    return returncode, stdout, stderr, artifacts


def generate_step_id() -> str:
    """Generate a unique step ID."""
    return f"s{uuid.uuid4().hex[:8]}"


def parse_nmap_xml(xml_content: str) -> Dict[str, Any]:
    """Parse Nmap XML output."""
    try:
        from xml.etree import ElementTree as ET
        
        root = ET.fromstring(xml_content)
        results = {
            "hosts_up": 0,
            "hosts_total": 0,
            "services": [],
            "hosts": []
        }
        
        for host in root.findall('.//host'):
            host_info = {"ip": "", "hostnames": [], "ports": []}
            
            # Get IP address
            address = host.find('address[@addrtype="ipv4"]')
            if address is not None:
                host_info["ip"] = address.get("addr", "")
            
            # Get hostnames
            hostnames = host.find('hostnames')
            if hostnames is not None:
                for hostname in hostnames.findall('hostname'):
                    host_info["hostnames"].append(hostname.get("name", ""))
            
            # Get port information
            ports = host.find('ports')
            if ports is not None:
                for port in ports.findall('port'):
                    port_info = {
                        "port": port.get("portid", ""),
                        "protocol": port.get("protocol", ""),
                        "state": "",
                        "service": "",
                        "version": ""
                    }
                    
                    state = port.find('state')
                    if state is not None:
                        port_info["state"] = state.get("state", "")
                    
                    service = port.find('service')
                    if service is not None:
                        port_info["service"] = service.get("name", "")
                        port_info["version"] = service.get("version", "")
                    
                    if port_info["state"] == "open":
                        host_info["ports"].append(port_info)
                        results["services"].append({
                            "ip": host_info["ip"],
                            "port": port_info["port"],
                            "service": port_info["service"],
                            "version": port_info["version"]
                        })
            
            # Check if host is up
            status = host.find('status')
            if status is not None and status.get("state") == "up":
                results["hosts_up"] += 1
                results["hosts"].append(host_info)
            
            results["hosts_total"] += 1
        
        return results
        
    except Exception as e:
        logger.error("Failed to parse Nmap XML", error=str(e))
        return {"error": str(e), "hosts_up": 0, "hosts_total": 0, "services": [], "hosts": []}


def parse_amass_output(output: str) -> Dict[str, Any]:
    """Parse Amass text output."""
    results = {
        "domains": [],
        "subdomains": [],
        "total_found": 0
    }
    
    try:
        lines = output.strip().split('\n')
        domains = set()
        subdomains = set()
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                # Remove any extra information after space
                domain = line.split()[0] if ' ' in line else line
                
                if domain:
                    # Count dots to determine if it's a subdomain
                    if domain.count('.') <= 1:
                        domains.add(domain)
                    else:
                        subdomains.add(domain)
        
        results["domains"] = sorted(list(domains))
        results["subdomains"] = sorted(list(subdomains))
        results["total_found"] = len(domains) + len(subdomains)
        
    except Exception as e:
        logger.error("Failed to parse Amass output", error=str(e))
        results["error"] = str(e)
    
    return results


def parse_nikto_output(output: str) -> Dict[str, Any]:
    """Parse Nikto text output."""
    results = {
        "target": "",
        "findings": [],
        "total_findings": 0,
        "severity_counts": {"info": 0, "low": 0, "medium": 0, "high": 0}
    }
    
    try:
        lines = output.strip().split('\n')
        current_target = ""
        
        for line in lines:
            line = line.strip()
            
            # Extract target
            if "Target IP:" in line or "Target Host:" in line:
                current_target = line.split(':', 1)[1].strip()
                results["target"] = current_target
            
            # Parse findings (lines starting with +)
            if line.startswith('+'):
                finding = {
                    "description": line[1:].strip(),
                    "severity": "info"  # Default severity
                }
                
                # Determine severity based on keywords
                line_lower = line.lower()
                if any(keyword in line_lower for keyword in ['critical', 'exploit', 'shell', 'backdoor']):
                    finding["severity"] = "high"
                elif any(keyword in line_lower for keyword in ['password', 'auth', 'login', 'admin']):
                    finding["severity"] = "medium"
                elif any(keyword in line_lower for keyword in ['version', 'banner', 'header']):
                    finding["severity"] = "low"
                
                results["findings"].append(finding)
                results["severity_counts"][finding["severity"]] += 1
        
        results["total_findings"] = len(results["findings"])
        
    except Exception as e:
        logger.error("Failed to parse Nikto output", error=str(e))
        results["error"] = str(e)
    
    return results


def validate_network_target(target: str, allowed_networks: List[str]) -> bool:
    """Validate if a network target is within allowed networks."""
    import ipaddress
    
    try:
        target_network = ipaddress.ip_network(target, strict=False)
        
        for allowed_net in allowed_networks:
            allowed_network = ipaddress.ip_network(allowed_net)
            if (target_network.subnet_of(allowed_network) or 
                target_network == allowed_network or
                target_network.supernet_of(allowed_network)):
                return True
        
        return False
        
    except (ipaddress.AddressValueError, ValueError):
        # If it's not a valid network, assume it's a domain/hostname
        return True


def sanitize_filename(filename: str) -> str:
    """Sanitize filename for safe filesystem usage."""
    import re
    
    # Remove or replace dangerous characters
    filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
    # Remove control characters
    filename = re.sub(r'[\x00-\x1f\x7f]', '', filename)
    # Limit length
    if len(filename) > 255:
        filename = filename[:255]
    
    return filename


def get_artifact_path(artifacts_dir: str, run_id: str, step_id: str, filename: str) -> Path:
    """Get artifact file path."""
    return Path(artifacts_dir) / run_id / step_id / sanitize_filename(filename)
