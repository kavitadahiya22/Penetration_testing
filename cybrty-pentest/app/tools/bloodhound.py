"""BloodHound Active Directory analysis agent."""

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

import httpx
import structlog

logger = structlog.get_logger(__name__)


class BloodHoundAgent:
    """BloodHound Active Directory analysis agent."""

    def __init__(self):
        """Initialize BloodHound agent."""
        pass

    async def analyze(
        self,
        data_path: Optional[str] = None,
        query: str = "shortest_path_to_da",
        neo4j_uri: Optional[str] = None,
        neo4j_user: Optional[str] = None,
        neo4j_password: Optional[str] = None,
        artifacts_dir: str = "/tmp",
        run_id: str = "test",
        step_id: str = "bh1",
        simulate: bool = True
    ) -> Dict[str, Any]:
        """Analyze BloodHound data."""
        started_at = datetime.utcnow()
        
        try:
            # Check if we have data to analyze
            if data_path:
                return await self._analyze_json_data(
                    data_path, query, artifacts_dir, run_id, step_id, started_at
                )
            elif neo4j_uri and neo4j_user and neo4j_password:
                return await self._analyze_neo4j_data(
                    neo4j_uri, neo4j_user, neo4j_password, query, started_at
                )
            else:
                return {
                    "status": "error",
                    "agent": "priv-esc",
                    "tool": "bloodhound",
                    "params": {"data_path": data_path, "query": query},
                    "summary": {"error": "No data source provided (JSON files or Neo4j connection)"},
                    "artifacts": {},
                    "started_at": started_at.isoformat(),
                    "ended_at": datetime.utcnow().isoformat(),
                    "duration_ms": 0
                }

        except Exception as e:
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            logger.error("BloodHound analysis failed", query=query, error=str(e))
            
            return {
                "status": "error",
                "agent": "priv-esc",
                "tool": "bloodhound",
                "params": {"data_path": data_path, "query": query},
                "summary": {"error": str(e)},
                "artifacts": {},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }

    async def _analyze_json_data(
        self,
        data_path: str,
        query: str,
        artifacts_dir: str,
        run_id: str,
        step_id: str,
        started_at: datetime
    ) -> Dict[str, Any]:
        """Analyze JSON data files."""
        try:
            data_dir = Path(data_path)
            if not data_dir.exists():
                raise ValueError(f"Data path {data_path} does not exist")

            # Look for common BloodHound JSON files
            json_files = list(data_dir.glob("*.json"))
            if not json_files:
                raise ValueError(f"No JSON files found in {data_path}")

            logger.info("Analyzing BloodHound JSON data", files=len(json_files), query=query)

            findings = []
            total_objects = 0

            # Analyze each JSON file
            for json_file in json_files:
                try:
                    with open(json_file, 'r') as f:
                        data = json.load(f)
                    
                    if isinstance(data, dict) and 'data' in data:
                        objects = data['data']
                        total_objects += len(objects)
                        
                        # Basic analysis based on query type
                        if query == "shortest_path_to_da":
                            findings.extend(self._find_admin_paths(objects))
                        elif query == "high_value_targets":
                            findings.extend(self._find_high_value_targets(objects))
                        elif query == "kerberoastable_users":
                            findings.extend(self._find_kerberoastable_users(objects))

                except json.JSONDecodeError:
                    logger.warning("Failed to parse JSON file", file=str(json_file))

            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)

            summary = {
                "query": query,
                "json_files_analyzed": len(json_files),
                "total_objects": total_objects,
                "findings": findings[:10],  # Limit to first 10 findings
                "total_findings": len(findings),
                "analysis_type": "offline_json"
            }

            return {
                "status": "success",
                "agent": "priv-esc",
                "tool": "bloodhound",
                "params": {"data_path": data_path, "query": query},
                "summary": summary,
                "artifacts": {"json_analysis": f"Analyzed {len(json_files)} BloodHound files"},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }

        except Exception as e:
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            raise e

    async def _analyze_neo4j_data(
        self,
        neo4j_uri: str,
        neo4j_user: str,
        neo4j_password: str,
        query: str,
        started_at: datetime
    ) -> Dict[str, Any]:
        """Analyze data via Neo4j connection."""
        try:
            # Test Neo4j connection (simplified)
            async with httpx.AsyncClient() as client:
                response = await client.get(neo4j_uri, timeout=10.0)
                if response.status_code != 200:
                    raise ValueError("Cannot connect to Neo4j database")

            logger.info("Analyzing BloodHound Neo4j data", query=query)

            # Simulate Neo4j query results
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)

            summary = {
                "query": query,
                "neo4j_connection": "success",
                "findings": [],  # Would contain actual query results
                "total_findings": 0,
                "analysis_type": "live_neo4j",
                "note": "Neo4j analysis simulation - implement actual Cypher queries"
            }

            return {
                "status": "success",
                "agent": "priv-esc",
                "tool": "bloodhound",
                "params": {"neo4j_uri": neo4j_uri, "query": query},
                "summary": summary,
                "artifacts": {"neo4j_analysis": f"Neo4j query: {query}"},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }

        except Exception as e:
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            raise e

    def _find_admin_paths(self, objects: list) -> list:
        """Find potential paths to domain admin."""
        findings = []
        for obj in objects:
            if isinstance(obj, dict) and obj.get('type') == 'User':
                properties = obj.get('properties', {})
                if properties.get('admincount', False):
                    findings.append({
                        "type": "admin_user",
                        "name": properties.get('name', 'Unknown'),
                        "severity": "high"
                    })
        return findings

    def _find_high_value_targets(self, objects: list) -> list:
        """Find high value targets."""
        findings = []
        for obj in objects:
            if isinstance(obj, dict):
                properties = obj.get('properties', {})
                if properties.get('highvalue', False):
                    findings.append({
                        "type": "high_value_target",
                        "name": properties.get('name', 'Unknown'),
                        "object_type": obj.get('type', 'Unknown'),
                        "severity": "medium"
                    })
        return findings

    def _find_kerberoastable_users(self, objects: list) -> list:
        """Find Kerberoastable users."""
        findings = []
        for obj in objects:
            if isinstance(obj, dict) and obj.get('type') == 'User':
                properties = obj.get('properties', {})
                if properties.get('hasspn', False):
                    findings.append({
                        "type": "kerberoastable_user",
                        "name": properties.get('name', 'Unknown'),
                        "severity": "medium"
                    })
        return findings
