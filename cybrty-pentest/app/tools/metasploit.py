"""Metasploit exploitation agent."""

from datetime import datetime
from typing import Any, Dict

import httpx
import structlog

from .utils import run_command_with_artifacts

logger = structlog.get_logger(__name__)


class MetasploitAgent:
    """Metasploit RPC exploitation agent."""

    def __init__(self, rpc_host: str = "msfrpcd", rpc_port: int = 55552, rpc_user: str = "msf"):
        """Initialize Metasploit agent."""
        self.rpc_host = rpc_host
        self.rpc_port = rpc_port
        self.rpc_user = rpc_user
        self.rpc_url = f"http://{rpc_host}:{rpc_port}/api/"

    async def exploit(
        self,
        host: str,
        module: str,
        payload: str,
        artifacts_dir: str = "/tmp",
        run_id: str = "test",
        step_id: str = "msf1",
        simulate: bool = True,
        exploit_simulation: bool = False
    ) -> Dict[str, Any]:
        """Execute Metasploit exploit."""
        started_at = datetime.utcnow()
        
        try:
            # Safety check - only simulate unless explicitly allowed
            if not simulate or not exploit_simulation:
                return {
                    "status": "blocked",
                    "agent": "exploit",
                    "tool": "metasploit",
                    "params": {"host": host, "module": module, "payload": payload},
                    "summary": {
                        "error": "Exploitation blocked by policy",
                        "note": "Enable exploit_simulation in policy and set simulate=true to run",
                        "preview": f"Would attempt {module} against {host} with {payload}"
                    },
                    "artifacts": {},
                    "started_at": started_at.isoformat(),
                    "ended_at": datetime.utcnow().isoformat(),
                    "duration_ms": 0
                }

            # Try RPC connection first
            result = await self._try_rpc_exploit(host, module, payload, simulate)
            if result:
                ended_at = datetime.utcnow()
                duration_ms = int((ended_at - started_at).total_seconds() * 1000)
                result.update({
                    "started_at": started_at.isoformat(),
                    "ended_at": ended_at.isoformat(),
                    "duration_ms": duration_ms
                })
                return result

            # Fall back to simulation preview
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)

            return {
                "status": "success",
                "agent": "exploit",
                "tool": "metasploit",
                "params": {"host": host, "module": module, "payload": payload},
                "summary": {
                    "simulation_mode": True,
                    "target": host,
                    "exploit_module": module,
                    "payload": payload,
                    "note": "Simulation only - no actual exploitation performed",
                    "total_findings": 0
                },
                "artifacts": {"simulation": f"Metasploit simulation: {module} -> {host}"},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }

        except Exception as e:
            ended_at = datetime.utcnow()
            duration_ms = int((ended_at - started_at).total_seconds() * 1000)
            logger.error("Metasploit exploit failed", host=host, module=module, error=str(e))
            
            return {
                "status": "error",
                "agent": "exploit",
                "tool": "metasploit",
                "params": {"host": host, "module": module, "payload": payload},
                "summary": {"error": str(e)},
                "artifacts": {},
                "started_at": started_at.isoformat(),
                "ended_at": ended_at.isoformat(),
                "duration_ms": duration_ms
            }

    async def _try_rpc_exploit(
        self,
        host: str,
        module: str,
        payload: str,
        simulate: bool
    ) -> Dict[str, Any]:
        """Try to connect to Metasploit RPC."""
        try:
            async with httpx.AsyncClient() as client:
                # Test RPC connection
                response = await client.post(
                    f"{self.rpc_url}version",
                    timeout=10.0
                )
                
                if response.status_code != 200:
                    return None

                logger.info("Connected to Metasploit RPC", simulate=simulate)

                # In simulation mode, just validate the module exists
                if simulate:
                    return {
                        "status": "success",
                        "agent": "exploit",
                        "tool": "metasploit",
                        "params": {"host": host, "module": module, "payload": payload},
                        "summary": {
                            "simulation_mode": True,
                            "rpc_available": True,
                            "module_validated": True,
                            "note": "RPC simulation - no actual exploitation",
                            "total_findings": 0
                        },
                        "artifacts": {"rpc_simulation": f"MSF RPC simulation: {module}"}
                    }

                # Real exploit would go here if allowed
                return None

        except Exception as e:
            logger.debug("Metasploit RPC not available", error=str(e))
            return None
