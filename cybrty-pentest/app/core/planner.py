"""CrewAI-based pentesting plan generation with LLM integration."""

import json
import uuid
from datetime import datetime
from typing import Any, Dict, List

import structlog

from .config import Settings
from .providers import ModelProvider, OpenAIProvider, OllamaProvider

logger = structlog.get_logger(__name__)


class CrewAIPentestPlanner:
    """CrewAI-powered pentesting plan generator with LLM integration."""

    def __init__(self, settings: Settings):
        """Initialize the CrewAI planner with model provider."""
        self.settings = settings
        self.provider = self._create_provider()

    def _create_provider(self) -> ModelProvider:
        """Create appropriate model provider based on configuration."""
        if self.settings.model.provider.lower() == "openai":
            return OpenAIProvider(
                model_name=self.settings.model.model_name,
                api_key_env=self.settings.model.api_key_env
            )
        elif self.settings.model.provider.lower() == "ollama":
            return OllamaProvider(
                model_name=self.settings.model.model_name,
                api_base=self.settings.model.api_base
            )
        else:
            raise ValueError(f"Unsupported model provider: {self.settings.model.provider}")

    async def generate_plan(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str
    ) -> Dict[str, Any]:
        """Generate a comprehensive pentesting plan using CrewAI and LLM."""
        start_time = datetime.utcnow()
        
        try:
            # Validate inputs
            self._validate_inputs(targets, depth, features)
            
            # Apply policy checks
            validated_targets = self._apply_policy_checks(targets)
            
            # Generate plan using LLM
            plan = await self._generate_crew_plan(
                validated_targets, depth, features, simulate, tenant_id
            )
            
            # Validate and enhance plan
            validated_plan = self._validate_plan(plan)
            
            # Add metadata
            validated_plan.update({
                "targets": validated_targets,
                "depth": depth,
                "features": features,
                "simulate": simulate,
                "tenant_id": tenant_id,
                "generated_at": start_time.isoformat(),
                "processing_time_ms": int((datetime.utcnow() - start_time).total_seconds() * 1000)
            })
            
            return validated_plan

        except Exception as e:
            logger.error("Failed to generate CrewAI plan", error=str(e), tenant_id=tenant_id)
            raise

    async def _generate_crew_plan(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str
    ) -> Dict[str, Any]:
        """Generate plan using LLM with CrewAI-specific prompts."""
        
        system_prompt = self._get_crewai_system_prompt()
        user_prompt = self._build_crewai_user_prompt(targets, depth, features, simulate)
        
        try:
            response = await self.provider.generate_plan(
                targets=targets,
                depth=depth,
                features=features,
                simulate=simulate,
                tenant_id=tenant_id,
                system_prompt=system_prompt,
                user_prompt=user_prompt
            )
            
            return response
            
        except Exception as e:
            logger.error("LLM plan generation failed", error=str(e))
            # Fallback to template-based planning
            return self._generate_fallback_plan(targets, depth, features, simulate)

    def _get_crewai_system_prompt(self) -> str:
        """Get system prompt for CrewAI plan generation."""
        return """You are an expert penetration testing planner that generates CrewAI-compatible execution plans.

Your role:
- Analyze target scope and requirements
- Select appropriate agents and tools
- Generate step-by-step execution plans
- Ensure compliance with security policies
- Output structured JSON plans only

Available CrewAI Agents:
- recon: Network reconnaissance (nmap, amass)
- web: Web application testing (zap, nikto, sqlmap)
- exploit: Vulnerability validation (metasploit)
- creds: Credential testing (hydra, crackmapexec)
- lateral: Lateral movement analysis (bloodhound, crackmapexec)
- priv-esc: Privilege escalation analysis (bloodhound)

Security Constraints:
- Only target allowed networks: 10.0.0.0/8, 192.168.0.0/16
- Maximum 4096 hosts per network scan
- Default to simulation mode unless explicitly authorized
- Respect rate limits and lockout protection

Output Format:
Return ONLY valid JSON with this structure:
{
  "plan_id": "uuid",
  "steps": [
    {
      "id": "step_id",
      "agent": "agent_name",
      "tool": "tool_name", 
      "params": {...},
      "depends_on": ["previous_step_id"],
      "description": "Step description"
    }
  ],
  "notes": "Safety and execution notes"
}"""

    def _build_crewai_user_prompt(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool
    ) -> str:
        """Build user prompt for plan generation."""
        return f"""Generate a CrewAI penetration testing plan:

Targets: {targets}
Depth: {depth} (quick=basic scans, standard=comprehensive, deep=extensive)
Features: {features}
Simulate: {simulate}

Requirements:
1. Start with reconnaissance for all targets
2. Sequence steps logically (recon → web → exploit → creds → lateral → priv-esc)
3. Include dependencies between steps
4. Use appropriate tools for each agent
5. Respect simulation mode and safety constraints
6. Generate 3-8 steps depending on depth and features

Return only the JSON plan structure."""

    def _generate_fallback_plan(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool
    ) -> Dict[str, Any]:
        """Generate fallback plan when LLM is unavailable."""
        plan_id = str(uuid.uuid4())
        steps = []
        step_counter = 1
        
        # Always start with reconnaissance
        if "recon" in features:
            for target in targets:
                if self._is_network_target(target):
                    steps.append({
                        "id": f"s{step_counter}",
                        "agent": "recon",
                        "tool": "nmap",
                        "params": {
                            "target": target,
                            "profile": "-sV -T4" if depth != "deep" else "-sV -sC -T4"
                        },
                        "depends_on": [],
                        "description": f"Network reconnaissance of {target}"
                    })
                    step_counter += 1
                else:
                    # Domain target
                    steps.append({
                        "id": f"s{step_counter}",
                        "agent": "recon", 
                        "tool": "amass",
                        "params": {
                            "domain": target,
                            "mode": "passive"
                        },
                        "depends_on": [],
                        "description": f"Subdomain enumeration for {target}"
                    })
                    step_counter += 1
        
        # Web application testing
        if "web" in features:
            web_targets = [t for t in targets if t.startswith(('http://', 'https://'))]
            for target in web_targets:
                steps.append({
                    "id": f"s{step_counter}",
                    "agent": "web",
                    "tool": "zap",
                    "params": {
                        "target": target,
                        "baseline": True
                    },
                    "depends_on": [s["id"] for s in steps if s["agent"] == "recon"],
                    "description": f"Web security scan of {target}"
                })
                step_counter += 1
        
        # Add other features based on depth and requirements
        if "exploit" in features and simulate:
            steps.append({
                "id": f"s{step_counter}",
                "agent": "exploit",
                "tool": "metasploit", 
                "params": {
                    "simulate": True,
                    "mode": "validation"
                },
                "depends_on": [s["id"] for s in steps],
                "description": "Vulnerability validation (simulation mode)"
            })
            step_counter += 1
        
        return {
            "plan_id": plan_id,
            "steps": steps,
            "notes": "Fallback plan generated - CrewAI agents will execute sequentially"
        }

    def _is_network_target(self, target: str) -> bool:
        """Check if target is a network/IP rather than domain."""
        import ipaddress
        try:
            ipaddress.ip_network(target, strict=False)
            return True
        except:
            return False

    def _validate_inputs(self, targets: List[str], depth: str, features: List[str]) -> None:
        """Validate input parameters."""
        if not targets:
            raise ValueError("At least one target must be specified")
        
        if depth not in ["quick", "standard", "deep"]:
            raise ValueError("Depth must be one of: quick, standard, deep")
        
        valid_features = ["recon", "web", "vuln", "exploit", "creds", "lateral", "priv-esc"]
        for feature in features:
            if feature not in valid_features:
                raise ValueError(f"Invalid feature: {feature}. Valid features: {valid_features}")

    def _apply_policy_checks(self, targets: List[str]) -> List[str]:
        """Apply security policy checks to targets."""
        import ipaddress
        
        validated_targets = []
        
        for target in targets:
            # Check if target is a URL (web targets are generally allowed)
            if target.startswith(('http://', 'https://')):
                validated_targets.append(target)
                continue
            
            # Check if target is a domain name
            if not any(char.isdigit() for char in target.replace('.', '').replace('/', '')):
                # Domain name - check if explicitly allowed or owned
                validated_targets.append(target)
                continue
            
            # Check if target is an IP/CIDR within allowed networks
            try:
                target_network = ipaddress.ip_network(target, strict=False)
                
                is_allowed = False
                for allowed_net in self.settings.policy.allow_networks:
                    try:
                        allowed_network = ipaddress.ip_network(allowed_net)
                        # Check if target is within allowed network using overlaps
                        if target_network.overlaps(allowed_network) or target_network == allowed_network:
                            # For subnet relationship, also check that target is smaller or equal
                            if target_network.num_addresses <= allowed_network.num_addresses:
                                is_allowed = True
                                break
                    except (ValueError, AttributeError):
                        # Skip invalid network specifications
                        continue
                
                if is_allowed:
                    # Check host count limit
                    if target_network.num_addresses > self.settings.policy.max_host_count:
                        raise ValueError(f"Target network {target} exceeds max host count limit")
                    validated_targets.append(target)
                else:
                    raise ValueError(f"Target {target} is not within allowed networks")
                    
            except ipaddress.AddressValueError:
                # Not a valid IP/CIDR, treat as hostname
                validated_targets.append(target)
        
        return validated_targets

    def _validate_plan(self, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Validate generated plan structure."""
        if not isinstance(plan, dict):
            raise ValueError("Plan must be a dictionary")
        
        if "steps" not in plan:
            raise ValueError("Plan must contain 'steps'")
        
        if not isinstance(plan["steps"], list):
            raise ValueError("Plan steps must be a list")
        
        # Ensure plan has an ID
        if "plan_id" not in plan:
            plan["plan_id"] = str(uuid.uuid4())
        
        # Validate each step
        valid_agents = ["recon", "web", "exploit", "creds", "lateral", "priv-esc"]
        valid_tools = ["nmap", "amass", "zap", "sqlmap", "nikto", "hydra", "crackmapexec", "metasploit", "bloodhound", "nuclei"]
        
        for i, step in enumerate(plan["steps"]):
            if not isinstance(step, dict):
                raise ValueError(f"Step {i} must be a dictionary")
            
            required_fields = ["id", "agent", "tool", "params"]
            for field in required_fields:
                if field not in step:
                    raise ValueError(f"Step {i} missing required field: {field}")
            
            if step["agent"] not in valid_agents:
                raise ValueError(f"Step {i} has invalid agent: {step['agent']}")
            
            if step["tool"] not in valid_tools:
                raise ValueError(f"Step {i} has invalid tool: {step['tool']}")
        
        # Add safety notes if missing
        if "notes" not in plan:
            plan["notes"] = "Plan generated with safety controls. Destructive actions require explicit enable."
        
        return plan

    async def health_check(self) -> bool:
        """Check if the planner and model provider are healthy."""
        try:
            return await self.provider.health_check()
        except Exception as e:
            logger.error("Planner health check failed", error=str(e))
            return False

    def get_provider_info(self) -> Dict[str, str]:
        """Get information about the current model provider."""
        return {
            "provider": self.provider.get_provider_name(),
            "model": self.settings.model.model_name,
            "api_base": self.settings.model.api_base
        }


# Alias for backward compatibility
PentestPlanner = CrewAIPentestPlanner
