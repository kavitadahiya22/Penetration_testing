"""Dedicated OpenSearch client module."""

import asyncio
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import structlog

try:
    from opensearchpy import OpenSearch
    from opensearchpy.exceptions import ConnectionError, NotFoundError, RequestError
    OPENSEARCH_AVAILABLE = True
except ImportError:
    # Fallback when opensearch-py is not available
    OPENSEARCH_AVAILABLE = False
    OpenSearch = None
    ConnectionError = Exception
    NotFoundError = Exception
    RequestError = Exception

from .config import OpenSearchConfig

logger = structlog.get_logger(__name__)


class OpenSearchClient:
    """Dedicated OpenSearch client for pentesting service."""

    def __init__(self, config: OpenSearchConfig):
        """Initialize OpenSearch client."""
        self.config = config
        self.client = None
        self._indices_created = set()
        self._healthy = False
        
        if OPENSEARCH_AVAILABLE and OpenSearch:
            try:
                self.client = OpenSearch(
                    hosts=[{
                        'host': config.host,
                        'port': config.port,
                        'use_ssl': config.scheme == 'https'
                    }],
                    http_auth=(config.username, config.password) if config.username else None,
                    use_ssl=config.scheme == 'https',
                    verify_certs=False,
                    ssl_assert_hostname=False,
                    ssl_show_warn=False,
                    timeout=30,
                    max_retries=3,
                    retry_on_timeout=True
                )
                logger.info("OpenSearch client initialized", host=config.host, port=config.port)
            except Exception as e:
                logger.warning("Failed to initialize OpenSearch client", error=str(e))
                self.client = None
        else:
            logger.info("OpenSearch client not available, using fallback logging")

    async def ensure_indices(self) -> None:
        """Ensure required indices exist with proper mappings."""
        if not self.client:
            logger.info("OpenSearch client not available, skipping index creation")
            return
            
        mappings_file = Path(__file__).parent.parent.parent / "config" / "samples" / "opensearch_index_mappings.json"
        
        if not mappings_file.exists():
            logger.warning("Index mappings file not found", file=str(mappings_file))
            return

        try:
            with open(mappings_file, 'r') as f:
                mappings = json.load(f)

            for index_name, mapping_config in mappings.items():
                await self._create_index_if_not_exists(index_name, mapping_config)
                self._indices_created.add(index_name)
                
            logger.info("OpenSearch indices ensured", indices=list(self._indices_created))
        except Exception as e:
            logger.error("Failed to ensure indices", error=str(e))

    async def _create_index_if_not_exists(self, index_name: str, mapping_config: Dict[str, Any]) -> None:
        """Create index if it doesn't exist."""
        if not self.client:
            return
            
        try:
            # Use synchronous client for index operations
            exists = self.client.indices.exists(index=index_name)
            if not exists:
                self.client.indices.create(index=index_name, body=mapping_config)
                logger.info("Created OpenSearch index", index=index_name)
            else:
                logger.debug("Index already exists", index=index_name)
        except Exception as e:
            logger.error("Failed to create index", index=index_name, error=str(e))

    async def index_document(self, index: str, doc: Dict[str, Any], doc_id: Optional[str] = None) -> bool:
        """Index a document with retries."""
        if not self.client:
            logger.debug("OpenSearch not available, logging to console", doc=doc)
            return True
            
        return await self._write_with_retries(index, doc, doc_id, retries=3)

    async def _write_with_retries(self, index: str, doc: Dict[str, Any], doc_id: Optional[str], retries: int) -> bool:
        """Write document with exponential backoff retries."""
        if not self.client:
            return True
            
        for attempt in range(retries + 1):
            try:
                # Add timestamp if not present
                if '@timestamp' not in doc:
                    doc['@timestamp'] = datetime.utcnow().isoformat()
                
                response = self.client.index(
                    index=index, 
                    body=doc,
                    id=doc_id
                )
                
                logger.debug("Document indexed successfully", 
                           index=index, 
                           doc_id=response.get('_id'),
                           attempt=attempt + 1)
                return True
                
            except (ConnectionError, RequestError) as e:
                if attempt < retries:
                    wait_time = 2 ** attempt
                    logger.warning("OpenSearch write failed, retrying", 
                                 index=index, 
                                 attempt=attempt + 1, 
                                 wait_time=wait_time,
                                 error=str(e))
                    await asyncio.sleep(wait_time)
                else:
                    logger.error("OpenSearch write failed after retries", 
                               index=index, 
                               attempts=retries + 1,
                               error=str(e))
                    return False
        
        return False

    async def search_documents(self, index: str, query: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Search documents in OpenSearch."""
        if not self.client:
            logger.debug("OpenSearch not available, returning empty results")
            return []
            
        try:
            response = self.client.search(index=index, body=query)
            hits = response.get('hits', {}).get('hits', [])
            return [hit['_source'] for hit in hits]
        except Exception as e:
            logger.error("Search failed", index=index, error=str(e))
            return []

    async def get_document(self, index: str, doc_id: str) -> Optional[Dict[str, Any]]:
        """Get a specific document by ID."""
        if not self.client:
            return None
            
        try:
            response = self.client.get(index=index, id=doc_id)
            return response.get('_source')
        except NotFoundError:
            return None
        except Exception as e:
            logger.error("Failed to get document", index=index, doc_id=doc_id, error=str(e))
            return None

    async def health_check(self) -> bool:
        """Check OpenSearch cluster health."""
        if not self.client:
            logger.debug("OpenSearch client not available")
            return False
            
        try:
            response = self.client.cluster.health()
            status = response.get('status', 'red')
            self._healthy = status in ['green', 'yellow']
            
            logger.debug("OpenSearch health check", 
                        status=status, 
                        healthy=self._healthy,
                        cluster_name=response.get('cluster_name'))
            
            return self._healthy
        except Exception as e:
            logger.warning("OpenSearch health check failed", error=str(e))
            self._healthy = False
            return False

    async def close(self) -> None:
        """Close the OpenSearch client connection."""
        if self.client:
            try:
                # Synchronous client doesn't need explicit close
                logger.info("OpenSearch client connection closed")
            except Exception as e:
                logger.warning("Error closing OpenSearch client", error=str(e))

    def is_healthy(self) -> bool:
        """Return current health status."""
        return self._healthy

    def is_available(self) -> bool:
        """Check if OpenSearch client is available."""
        return self.client is not None


# Factory function for dependency injection
def create_opensearch_client(config: OpenSearchConfig) -> OpenSearchClient:
    """Create and return an OpenSearch client instance."""
    return OpenSearchClient(config)
