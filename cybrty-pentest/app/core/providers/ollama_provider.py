"""Ollama model provider implementation."""

import json
import uuid
from typing import Any, Dict, List

import httpx
import structlog

from .base import ModelProvider

logger = structlog.get_logger(__name__)


class OllamaProvider(ModelProvider):
    """Ollama local model provider."""

    def __init__(self, model_name: str, api_base: str):
        """Initialize Ollama provider."""
        self.model_name = model_name
        self.api_base = api_base.rstrip('/')

    async def generate_plan(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str,
        **kwargs
    ) -> Dict[str, Any]:
        """Generate a pentesting plan using Ollama."""
        system_prompt = self._get_system_prompt()
        user_prompt = self._build_user_prompt(targets, depth, features, simulate, tenant_id)

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.api_base}/api/generate",
                    json={
                        "model": self.model_name,
                        "prompt": f"{system_prompt}\n\nUser: {user_prompt}\n\nAssistant: ",
                        "stream": False,
                        "options": {
                            "temperature": 0.1,
                            "top_p": 0.9,
                            "num_predict": 4000
                        }
                    },
                    timeout=120.0
                )
                response.raise_for_status()

                result = response.json()
                content = result["response"]
                
                # Extract JSON from response (may contain extra text)
                content = self._extract_json(content)
                
                # Parse JSON response
                plan = json.loads(content)
                
                # Validate and add plan_id if missing
                if "plan_id" not in plan:
                    plan["plan_id"] = str(uuid.uuid4())
                
                return plan

        except json.JSONDecodeError as e:
            logger.error("Failed to parse Ollama response as JSON", error=str(e), content=content)
            raise ValueError(f"Invalid JSON response from Ollama: {e}")
        except httpx.HTTPStatusError as e:
            logger.error("Ollama API error", status_code=e.response.status_code, error=str(e))
            raise ValueError(f"Ollama API error: {e.response.status_code}")
        except Exception as e:
            logger.error("Unexpected error calling Ollama", error=str(e))
            raise ValueError(f"Failed to generate plan: {e}")

    async def health_check(self) -> bool:
        """Check Ollama API health."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.api_base}/api/tags",
                    timeout=10.0
                )
                return response.status_code == 200
        except Exception as e:
            logger.error("Ollama health check failed", error=str(e))
            return False

    def get_provider_name(self) -> str:
        """Get provider name."""
        return "ollama"

    def _extract_json(self, content: str) -> str:
        """Extract JSON from Ollama response that may contain extra text."""
        # Look for JSON object boundaries
        start_idx = content.find('{')
        if start_idx == -1:
            raise ValueError("No JSON object found in response")
        
        # Find the matching closing brace
        brace_count = 0
        end_idx = start_idx
        
        for i, char in enumerate(content[start_idx:], start_idx):
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_idx = i + 1
                    break
        
        if brace_count != 0:
            raise ValueError("Incomplete JSON object in response")
        
        return content[start_idx:end_idx]

    def _get_system_prompt(self) -> str:
        """Get the system prompt for plan generation."""
        return """You are a cybersecurity expert specializing in penetration testing. Your task is to generate safe, structured pentesting plans based on user inputs.

CRITICAL REQUIREMENTS:
1. Always return valid JSON only, no other text or explanations
2. Default to non-destructive actions unless explicitly allowed
3. Respect network allowlists and host count limits
4. Use simulation mode for potentially destructive actions
5. Include all requested features in logical order

AGENTS AVAILABLE:
- recon: Nmap, Amass (passive reconnaissance)
- web: ZAP, SQLMap, Nikto (web application testing)
- exploit: Metasploit RPC (exploitation framework)
- creds: Hydra, CrackMapExec (credential testing)
- lateral: BloodHound, CrackMapExec (lateral movement)
- priv-esc: BloodHound path analysis (privilege escalation)

TOOLS MAPPING:
- amass: passive domain/subdomain enumeration
- nmap: network and service discovery
- zap: web application baseline scanning
- sqlmap: SQL injection testing
- nikto: web server vulnerability scanning
- hydra: password brute forcing (with rate limits)
- crackmapexec: Windows/SMB enumeration and exploitation
- metasploit: exploit framework via RPC
- bloodhound: Active Directory analysis

JSON SCHEMA:
{
  "plan_id": "uuid",
  "steps": [
    {
      "id": "s1",
      "agent": "recon|web|exploit|creds|lateral|priv-esc",
      "tool": "nmap|amass|zap|sqlmap|nikto|hydra|crackmapexec|metasploit|bloodhound",
      "params": {...}
    }
  ],
  "notes": "Safety and execution notes"
}

Always include safety notes explaining simulation mode and destructive action controls."""

    def _build_user_prompt(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str
    ) -> str:
        """Build the user prompt for plan generation."""
        return f"""Generate a pentesting plan for:

TARGETS: {', '.join(targets)}
DEPTH: {depth}
FEATURES: {', '.join(features)}
SIMULATE: {simulate}
TENANT_ID: {tenant_id}

Create a logical sequence of steps using the requested features. Start with reconnaissance, then proceed to more invasive testing based on depth setting.

DEPTH GUIDELINES:
- quick: Basic recon + minimal testing (2-4 steps)
- standard: Comprehensive recon + moderate testing (4-8 steps)
- deep: Full reconnaissance + extensive testing (8+ steps)

Ensure all steps are safe for the target environment and respect the simulate flag.

Return ONLY the JSON plan, no other text."""
