"""OpenAI model provider implementation."""

import json
import os
import uuid
from typing import Any, Dict, List

import httpx
import structlog

from .base import ModelProvider

logger = structlog.get_logger(__name__)


class OpenAIProvider(ModelProvider):
    """OpenAI GPT model provider."""

    def __init__(self, model_name: str, api_key_env: str):
        """Initialize OpenAI provider."""
        self.model_name = model_name
        self.api_key = os.getenv(api_key_env)
        if not self.api_key:
            raise ValueError(f"OpenAI API key not found in environment variable: {api_key_env}")
        
        self.base_url = "https://api.openai.com/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

    async def generate_plan(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str,
        **kwargs
    ) -> Dict[str, Any]:
        """Generate a pentesting plan using OpenAI."""
        system_prompt = self._get_system_prompt()
        user_prompt = self._build_user_prompt(targets, depth, features, simulate, tenant_id)

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/chat/completions",
                    headers=self.headers,
                    json={
                        "model": self.model_name,
                        "messages": [
                            {"role": "system", "content": system_prompt},
                            {"role": "user", "content": user_prompt}
                        ],
                        "temperature": 0.1,
                        "max_tokens": 4000
                    },
                    timeout=60.0
                )
                response.raise_for_status()

                result = response.json()
                content = result["choices"][0]["message"]["content"]
                
                # Parse JSON response
                plan = json.loads(content)
                
                # Validate and add plan_id if missing
                if "plan_id" not in plan:
                    plan["plan_id"] = str(uuid.uuid4())
                
                return plan

        except json.JSONDecodeError as e:
            logger.error("Failed to parse OpenAI response as JSON", error=str(e))
            raise ValueError(f"Invalid JSON response from OpenAI: {e}")
        except httpx.HTTPStatusError as e:
            logger.error("OpenAI API error", status_code=e.response.status_code, error=str(e))
            raise ValueError(f"OpenAI API error: {e.response.status_code}")
        except Exception as e:
            logger.error("Unexpected error calling OpenAI", error=str(e))
            raise ValueError(f"Failed to generate plan: {e}")

    async def health_check(self) -> bool:
        """Check OpenAI API health."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/models",
                    headers=self.headers,
                    timeout=10.0
                )
                return response.status_code == 200
        except Exception as e:
            logger.error("OpenAI health check failed", error=str(e))
            return False

    def get_provider_name(self) -> str:
        """Get provider name."""
        return "openai"

    def _get_system_prompt(self) -> str:
        """Get the system prompt for plan generation."""
        return """You are a cybersecurity expert specializing in penetration testing. Your task is to generate safe, structured pentesting plans based on user inputs.

CRITICAL REQUIREMENTS:
1. Always return valid JSON only, no other text
2. Default to non-destructive actions unless explicitly allowed
3. Respect network allowlists and host count limits
4. Use simulation mode for potentially destructive actions
5. Include all requested features in logical order

AGENTS AVAILABLE:
- recon: Nmap, Amass (passive reconnaissance)
- web: ZAP, SQLMap, Nikto (web application testing)
- exploit: Metasploit RPC (exploitation framework)
- creds: Hydra, CrackMapExec (credential testing)
- lateral: BloodHound, CrackMapExec (lateral movement)
- priv-esc: BloodHound path analysis (privilege escalation)

TOOLS MAPPING:
- amass: passive domain/subdomain enumeration
- nmap: network and service discovery
- zap: web application baseline scanning
- sqlmap: SQL injection testing
- nikto: web server vulnerability scanning
- hydra: password brute forcing (with rate limits)
- crackmapexec: Windows/SMB enumeration and exploitation
- metasploit: exploit framework via RPC
- bloodhound: Active Directory analysis

JSON SCHEMA:
{
  "plan_id": "uuid",
  "steps": [
    {
      "id": "s1",
      "agent": "recon|web|exploit|creds|lateral|priv-esc",
      "tool": "nmap|amass|zap|sqlmap|nikto|hydra|crackmapexec|metasploit|bloodhound",
      "params": {...}
    }
  ],
  "notes": "Safety and execution notes"
}

Always include safety notes explaining simulation mode and destructive action controls."""

    def _build_user_prompt(
        self,
        targets: List[str],
        depth: str,
        features: List[str],
        simulate: bool,
        tenant_id: str
    ) -> str:
        """Build the user prompt for plan generation."""
        return f"""Generate a pentesting plan for:

TARGETS: {', '.join(targets)}
DEPTH: {depth}
FEATURES: {', '.join(features)}
SIMULATE: {simulate}
TENANT_ID: {tenant_id}

Create a logical sequence of steps using the requested features. Start with reconnaissance, then proceed to more invasive testing based on depth setting.

DEPTH GUIDELINES:
- quick: Basic recon + minimal testing (2-4 steps)
- standard: Comprehensive recon + moderate testing (4-8 steps)
- deep: Full reconnaissance + extensive testing (8+ steps)

Ensure all steps are safe for the target environment and respect the simulate flag."""
