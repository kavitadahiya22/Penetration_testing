"""OpenSearch client and logging utilities."""

import time
from datetime import datetime
from typing import Any, Dict, List, Optional

import structlog

from .config import OpenSearchConfig, Settings
from .opensearch_client import OpenSearchClient, create_opensearch_client

logger = structlog.get_logger(__name__)


class OpenSearchLogger:
    """OpenSearch client for logging pentesting actions and runs."""

    def __init__(self, config: OpenSearchConfig):
        """Initialize OpenSearch client."""
        self.config = config
        self.client = None
        self._indices_created = set()
        
        if OPENSEARCH_AVAILABLE and AsyncOpenSearch:
            try:
                self.client = AsyncOpenSearch(
                    hosts=[{
                        'host': config.host,
                        'port': config.port
                    }],
                    http_auth=(config.username, config.password) if config.username else None,
                    use_ssl=config.scheme == 'https',
                    verify_certs=False,
                    ssl_assert_hostname=False,
                    ssl_show_warn=False,
                    connection_class=RequestsHttpConnection,
                )
            except Exception as e:
                logger.warning("Failed to initialize OpenSearch client", error=str(e))
                self.client = None
        else:
            logger.info("OpenSearch client not available, using fallback logging")

    async def ensure_indices(self) -> None:
        """Ensure required indices exist with proper mappings."""
        if not self.client:
            return
            
        mappings_file = Path(__file__).parent.parent.parent / "config" / "samples" / "opensearch_index_mappings.json"
        
        if not mappings_file.exists():
            logger.warning("Index mappings file not found", file=str(mappings_file))
            return

        try:
            with open(mappings_file, 'r') as f:
                mappings = json.load(f)

            for index_name, mapping_config in mappings.items():
                if index_name not in self._indices_created:
                    await self._create_index_if_not_exists(index_name, mapping_config)
                    self._indices_created.add(index_name)

        except Exception as e:
            logger.error("Failed to load index mappings", error=str(e))

    async def _create_index_if_not_exists(self, index_name: str, mapping_config: Dict[str, Any]) -> None:
        """Create index if it doesn't exist."""
        try:
            exists = await self.client.indices.exists(index=index_name)
            if not exists:
                await self.client.indices.create(index=index_name, body=mapping_config)
                logger.info("Created OpenSearch index", index=index_name)
        except Exception as e:
            logger.error("Failed to create index", index=index_name, error=str(e))

    async def log_action(
        self,
        run_id: str,
        step_id: str,
        tenant_id: str,
        agent: str,
        tool: str,
        status: str,
        params: Dict[str, Any],
        summary: Dict[str, Any],
        artifacts: Dict[str, Any],
        started_at: datetime,
        ended_at: datetime,
        duration_ms: int,
        error_message: Optional[str] = None,
        retries: int = 3
    ) -> bool:
        """Log a pentesting action to OpenSearch with retries."""
        doc = {
            "run_id": run_id,
            "step_id": step_id,
            "tenant_id": tenant_id,
            "agent": agent,
            "tool": tool,
            "status": status,
            "params": params,
            "summary": summary,
            "artifacts": artifacts,
            "started_at": started_at.isoformat(),
            "ended_at": ended_at.isoformat(),
            "duration_ms": duration_ms,
            "error_message": error_message,
            "created_at": datetime.utcnow().isoformat()
        }

        return await self._write_with_retries(self.config.index_actions, doc, retries)

    async def log_run(
        self,
        run_id: str,
        tenant_id: str,
        status: str,
        steps_count: int,
        total_findings: int,
        severity: str,
        started_at: datetime,
        ended_at: datetime,
        duration_ms: int,
        artifacts: List[str],
        plan_id: str,
        features: List[str],
        depth: str,
        simulate: bool,
        retries: int = 3
    ) -> bool:
        """Log a pentesting run to OpenSearch with retries."""
        doc = {
            "run_id": run_id,
            "tenant_id": tenant_id,
            "status": status,
            "steps_count": steps_count,
            "total_findings": total_findings,
            "severity": severity,
            "started_at": started_at.isoformat(),
            "ended_at": ended_at.isoformat(),
            "duration_ms": duration_ms,
            "artifacts": artifacts,
            "plan_id": plan_id,
            "features": features,
            "depth": depth,
            "simulate": simulate,
            "created_at": datetime.utcnow().isoformat()
        }

        return await self._write_with_retries(self.config.index_runs, doc, retries)

    async def _write_with_retries(self, index: str, doc: Dict[str, Any], retries: int) -> bool:
        """Write document to OpenSearch with exponential backoff."""
        for attempt in range(retries):
            try:
                await self.ensure_indices()
                response = await self.client.index(index=index, body=doc)
                logger.debug("Logged to OpenSearch", index=index, doc_id=response.get('_id'))
                return True
            except Exception as e:
                wait_time = 2 ** attempt
                logger.warning(
                    "Failed to write to OpenSearch, retrying",
                    index=index,
                    attempt=attempt + 1,
                    max_retries=retries,
                    wait_time=wait_time,
                    error=str(e)
                )
                if attempt < retries - 1:
                    await asyncio.sleep(wait_time)
                else:
                    logger.error("Failed to write to OpenSearch after all retries", index=index, error=str(e))
                    return False

    async def get_run_status(self, run_id: str) -> Optional[Dict[str, Any]]:
        """Get run status from OpenSearch."""
        try:
            # Get run document
            run_query = {
                "query": {
                    "term": {"run_id": run_id}
                }
            }
            run_response = await self.client.search(index=self.config.index_runs, body=run_query)
            
            if not run_response['hits']['hits']:
                return None

            run_doc = run_response['hits']['hits'][0]['_source']

            # Get action documents
            actions_query = {
                "query": {
                    "term": {"run_id": run_id}
                },
                "sort": [{"started_at": {"order": "asc"}}]
            }
            actions_response = await self.client.search(index=self.config.index_actions, body=actions_query)
            
            steps = []
            for hit in actions_response['hits']['hits']:
                step = hit['_source']
                steps.append({
                    "id": step['step_id'],
                    "agent": step['agent'],
                    "tool": step['tool'],
                    "status": step['status']
                })

            current_step = len([s for s in steps if s['status'] in ['success', 'error']])
            
            return {
                "run_id": run_id,
                "status": run_doc['status'],
                "progress": {
                    "current": current_step,
                    "total": run_doc['steps_count']
                },
                "steps": steps,
                "artifacts": run_doc.get('artifacts', [])
            }

        except Exception as e:
            logger.error("Failed to get run status", run_id=run_id, error=str(e))
            return None

    async def health_check(self) -> bool:
        """Check OpenSearch health."""
        try:
            response = await self.client.cluster.health()
            return response['status'] in ['green', 'yellow']
        except Exception as e:
            logger.error("OpenSearch health check failed", error=str(e))
            return False

    async def close(self) -> None:
        """Close OpenSearch client."""
        await self.client.close()


def get_opensearch_logger(settings: Settings) -> OpenSearchLogger:
    """Get OpenSearch logger instance."""
    return OpenSearchLogger(settings.opensearch)
