"""CrewAI registry for managing agents and crews."""

from typing import Dict, List, Any, Optional
from crewai import Agent, Crew, Task
from crewai.tools import BaseTool

from .roles import AgentRoles
from .tasks import TaskTemplates
from ..config import Settings
from ...tools import NmapTool
# TODO: Add other CrewAI tool wrappers as they are implemented
# AmasseTool, ZapTool, SqlmapTool, NiktoTool,
# HydraTool, CrackMapExecTool, MetasploitTool, BloodHoundTool


class CrewRegistry:
    """Registry for managing CrewAI agents and crews."""
    
    def __init__(self, settings: Settings):
        """Initialize the crew registry."""
        self.settings = settings
        self._agents: Dict[str, Agent] = {}
        self._tools: Dict[str, List[BaseTool]] = {}
        self._initialize_tools()
        self._initialize_agents()
    
    def _initialize_tools(self) -> None:
        """Initialize all available tools."""
        # Start with basic tools - will expand as more CrewAI wrappers are implemented
        nmap_tool = NmapTool(self.settings)
        
        self._tools = {
            "recon": [nmap_tool],
            "web": [nmap_tool],  # Temporary - will add ZapTool, SqlmapTool, NiktoTool
            "exploit": [nmap_tool],  # Temporary - will add MetasploitTool
            "creds": [nmap_tool],  # Temporary - will add HydraTool, CrackMapExecTool
            "lateral": [nmap_tool],  # Temporary - will add BloodHoundTool, CrackMapExecTool
            "priv-esc": [nmap_tool]  # Temporary - will add BloodHoundTool, CrackMapExecTool
        }
    
    def _initialize_agents(self) -> None:
        """Initialize all agents."""
        roles = AgentRoles.get_all_roles()
        
        for agent_name, role_config in roles.items():
            tools = self._tools.get(agent_name, [])
            
            agent = Agent(
                role=role_config["role"],
                goal=role_config["goal"],
                backstory=role_config["backstory"],
                tools=tools,
                verbose=role_config.get("verbose", True),
                allow_delegation=role_config.get("allow_delegation", False),
                max_iter=role_config.get("max_iter", 3),
                memory=role_config.get("memory", True)
            )
            
            self._agents[agent_name] = agent
    
    def get_agent(self, agent_name: str) -> Optional[Agent]:
        """Get agent by name."""
        return self._agents.get(agent_name)
    
    def get_available_agents(self) -> List[str]:
        """Get list of available agent names."""
        return list(self._agents.keys())
    
    def get_available_tools(self) -> Dict[str, List[str]]:
        """Get available tools by agent."""
        return {
            agent: [tool.__class__.__name__.replace("Tool", "").lower() 
                   for tool in tools]
            for agent, tools in self._tools.items()
        }
    
    def create_crew(self, plan_steps: List[Dict[str, Any]]) -> Crew:
        """Create a crew based on plan steps."""
        agents = []
        tasks = []
        
        # Get unique agents needed for this plan
        agent_names = list(set(step["agent"] for step in plan_steps))
        
        for agent_name in agent_names:
            agent = self.get_agent(agent_name)
            if agent:
                agents.append(agent)
        
        # Create tasks for each step
        for step in plan_steps:
            agent_name = step["agent"]
            agent = self.get_agent(agent_name)
            
            if not agent:
                continue
            
            # Create task based on step parameters
            if agent_name == "recon":
                targets = step["params"].get("targets", [])
                task_config = TaskTemplates.create_recon_task(targets, step["params"])
            elif agent_name == "web":
                urls = step["params"].get("urls", [])
                task_config = TaskTemplates.create_web_task(urls, step["params"])
            elif agent_name == "exploit":
                target = step["params"].get("target", "")
                task_config = TaskTemplates.create_exploit_task(target, step["params"])
            elif agent_name == "creds":
                targets = step["params"].get("targets", [])
                task_config = TaskTemplates.create_creds_task(targets, step["params"])
            elif agent_name == "lateral":
                domain = step["params"].get("domain", "")
                task_config = TaskTemplates.create_lateral_task(domain, step["params"])
            elif agent_name == "priv-esc":
                targets = step["params"].get("targets", [])
                task_config = TaskTemplates.create_privesc_task(targets, step["params"])
            else:
                continue
            
            task = Task(
                description=task_config["description"],
                expected_output=task_config["expected_output"],
                agent=agent
            )
            
            tasks.append(task)
        
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=True,
            memory=True
        )
    
    def get_capability_matrix(self) -> Dict[str, Any]:
        """Get capability matrix for all agents."""
        matrix = {}
        
        for agent_name, agent in self._agents.items():
            tools = self._tools.get(agent_name, [])
            
            matrix[agent_name] = {
                "role": agent.role,
                "goal": agent.goal,
                "tools": [tool.__class__.__name__.replace("Tool", "").lower() 
                         for tool in tools],
                "capabilities": self._get_agent_capabilities(agent_name)
            }
        
        return matrix
    
    def _get_agent_capabilities(self, agent_name: str) -> List[str]:
        """Get capabilities for specific agent."""
        capabilities_map = {
            "recon": [
                "passive_reconnaissance",
                "subdomain_enumeration", 
                "port_scanning",
                "service_discovery",
                "host_discovery"
            ],
            "web": [
                "web_vulnerability_scanning",
                "sql_injection_testing",
                "directory_discovery",
                "authentication_testing",
                "session_management_testing"
            ],
            "exploit": [
                "vulnerability_validation",
                "controlled_exploitation",
                "payload_generation",
                "post_exploitation",
                "impact_assessment"
            ],
            "creds": [
                "credential_testing",
                "brute_force_attacks",
                "password_spraying",
                "authentication_bypass",
                "credential_harvesting"
            ],
            "lateral": [
                "lateral_movement_analysis",
                "privilege_mapping",
                "domain_enumeration",
                "trust_relationship_analysis",
                "attack_path_discovery"
            ],
            "priv-esc": [
                "privilege_escalation_analysis",
                "misconfiguration_detection",
                "service_account_analysis",
                "delegation_analysis",
                "escalation_path_mapping"
            ]
        }
        
        return capabilities_map.get(agent_name, [])

    def create_simple_crew(self, agent_names: List[str]) -> Crew:
        """Create a crew with specified agent names (for testing/simple operations)."""
        agents = []
        
        for agent_name in agent_names:
            agent = self.get_agent(agent_name)
            if agent:
                agents.append(agent)
        
        if not agents:
            raise ValueError(f"No valid agents found from: {agent_names}")
        
        # Create a simple task for the crew
        task = Task(
            description="Perform security assessment as coordinated by the crew.",
            expected_output="Detailed security assessment report with findings and recommendations.",
            agent=agents[0]  # Assign to first agent
        )
        
        return Crew(
            agents=agents,
            tasks=[task],
            verbose=True
        )
